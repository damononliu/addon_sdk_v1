
/**
 * @file			oledi2c.c
 * @brief			wifiIO驱动IIC OLED的测试程序
 *	main函数中定义了两个引脚分别作为SDA和SCL 连接好硬件。将程序以"oled"的名称运行
 *	Thanks to http://learn.adafruit.com/monochrome-oled-breakouts/overview
 *  https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/common/I2C.cpp
 *  http://www.adafruit.com/datasheets/SSD1306.pdf

 * @author			yizuoshe@gmail.com
*/




#include "include.h"

#define SSD1306_LCDWIDTH                  128
#define SSD1306_LCDHEIGHT                 64

#define SSD1306_SETCONTRAST 0x81
#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_DISPLAYALLON 0xA5
#define SSD1306_NORMALDISPLAY 0xA6
#define SSD1306_INVERTDISPLAY 0xA7
#define SSD1306_DISPLAYOFF 0xAE
#define SSD1306_DISPLAYON 0xAF

#define SSD1306_SETDISPLAYOFFSET 0xD3
#define SSD1306_SETCOMPINS 0xDA

#define SSD1306_SETVCOMDETECT 0xDB

#define SSD1306_SETDISPLAYCLOCKDIV 0xD5
#define SSD1306_SETPRECHARGE 0xD9

#define SSD1306_SETMULTIPLEX 0xA8

#define SSD1306_SETLOWCOLUMN 0x00
#define SSD1306_SETHIGHCOLUMN 0x10

#define SSD1306_SETSTARTLINE 0x40

#define SSD1306_MEMORYMODE 0x20

#define SSD1306_COMSCANINC 0xC0
#define SSD1306_COMSCANDEC 0xC8

#define SSD1306_SEGREMAP 0xA0

#define SSD1306_CHARGEPUMP 0x8D

#define SSD1306_EXTERNALVCC 0x1
#define SSD1306_SWITCHCAPVCC 0x2

// Scrolling #defines
#define SSD1306_ACTIVATE_SCROLL 0x2F
#define SSD1306_DEACTIVATE_SCROLL 0x2E
#define SSD1306_SET_VERTICAL_SCROLL_AREA 0xA3
#define SSD1306_RIGHT_HORIZONTAL_SCROLL 0x26
#define SSD1306_LEFT_HORIZONTAL_SCROLL 0x27
#define SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL 0x29
#define SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL 0x2A

#define _BV(bit) (1 << (bit))


#define OLED_I2C_SCL WIFIIO_GPIO_17
#define OLED_I2C_SDA WIFIIO_GPIO_18

#define SSD1306_ADDR_WR (0x3C<<1)


typedef struct{
	i2c_sim_dev_t i2c_dev;
	u8_t buf[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8];
}ssd1306_dev_t;


ssd1306_dev_t ssd1306_dev = {
	.i2c_dev = {0,0,0},
	.buf = { 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
		0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
		0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
		0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
		0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
		0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
		0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
		0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
		0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
		0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
		0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
		0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
		0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
		0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
		0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

		0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
		0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
		0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
		0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
		0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
		0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
		0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
		0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
		0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
		0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
		0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
		0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}

};


int ssd1306_command(u8_t c)
{
	u8_t control = 0x00;   // Co = 0, D/C = 0
	i2c_sim_dev_t* i2c_pdev = &(ssd1306_dev.i2c_dev);

/*
	int err = 0;
	if(STATE_OK != i2c_sim.start(i2c_pdev)){			//启动总线
		err = -1;
		goto exit_error;
	}

	i2c_sim.tx(i2c_pdev, SSD1306_ADDR_WR);		//发送器件地址

	if(STATE_OK != i2c_sim.get_ack(i2c_pdev)){
		i2c_sim.stop(i2c_pdev); 
		err = -2;
		goto exit_error;
	}

	i2c_sim.tx(i2c_pdev, control);
	if(STATE_OK != i2c_sim.get_ack(i2c_pdev)){
		i2c_sim.stop(i2c_pdev); 
		err = -3;
		goto exit_error;
	}

	i2c_sim.tx(i2c_pdev, c);
	if(STATE_OK != i2c_sim.get_ack(i2c_pdev)){
		i2c_sim.stop(i2c_pdev); 
		err = -4;
		goto exit_error;
	}

*/
	i2c_sim.start(i2c_pdev);
	i2c_sim.tx(i2c_pdev, SSD1306_ADDR_WR);	
	i2c_sim.get_ack(i2c_pdev);
	i2c_sim.tx(i2c_pdev, control);
	i2c_sim.get_ack(i2c_pdev);
	i2c_sim.tx(i2c_pdev, c);
	i2c_sim.get_ack(i2c_pdev);

	i2c_sim.stop(i2c_pdev); 
	return STATE_OK;

/*

exit_error:
	LOG_WARN("IIC err: %d\r\n", err);
	return STATE_ERROR;

*/

}

void display(void)
{
	int i, j;
	i2c_sim_dev_t* i2c_pdev = &(ssd1306_dev.i2c_dev);

	ssd1306_command(SSD1306_SETLOWCOLUMN | 0x0);	// low col = 0
	ssd1306_command(SSD1306_SETHIGHCOLUMN | 0x0);	// hi col = 0
	ssd1306_command(SSD1306_SETSTARTLINE | 0x0); // line #0

	for (i = 0; i < (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++) {
		// send a bunch of data in one xmission

		i2c_sim.start(i2c_pdev);
		i2c_sim.tx(i2c_pdev, SSD1306_ADDR_WR);	
		i2c_sim.get_ack(i2c_pdev);

		i2c_sim.tx(i2c_pdev, 0x40);
		i2c_sim.get_ack(i2c_pdev);

		for (j = 0; j < 16; j++) {
			i2c_sim.tx(i2c_pdev, ssd1306_dev.buf[i]);
			i2c_sim.get_ack(i2c_pdev);
			i++;
		}
		i--;

		i2c_sim.stop(i2c_pdev); 
	}

}


void clearDisplay(void) {
	_memset(ssd1306_dev.buf, 0, (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8));
}


void drawPixel(int x, int y, u8_t color) {
	if ((x < 0) || (x >= SSD1306_LCDWIDTH) || (y < 0) || (y >= SSD1306_LCDHEIGHT))
		return;

	// check rotation, move pixel around if necessary
/*
	switch (getRotation()) {
	case 1:
		swap(x, y);
		x = WIDTH - x - 1;
		break;
	case 2:
		x = WIDTH - x - 1;
		y = HEIGHT - y - 1;
		break;
	case 3:
		swap(x, y);
		y = HEIGHT - y - 1;
		break;
	}	*/

	// x is which column
	if (color) 
		ssd1306_dev.buf[x+ (y/8)*SSD1306_LCDWIDTH] |= _BV((y%8));	
	else
		ssd1306_dev.buf[x+ (y/8)*SSD1306_LCDWIDTH] &= ~_BV((y%8)); 
}

//画线
void line(u8_t  x1, u8_t  y1, u8_t  x2, u8_t  y2, u8_t color)
{
	u8_t  x, y, t;
	if((x1 == x2) && (y1 == y2))
		drawPixel(x1, y1, color);
	else if(ABS(y2 - y1) > ABS(x2 - x1))
	{
		if(y1 > y2)
		{
			t = y1;
			y1 = y2;
			y2 = t;
			t = x1;
			x1 = x2;
			x2 = t;
		}
		for(y = y1; y <= y2; y ++)
		{
			x = (y - y1) * (x2 - x1) / (y2 - y1) + x1;
			drawPixel(x, y, color);
		}
	}
	else
	{
		if(x1 > x2)
		{
			t = y1;
			y1 = y2;
			y2 = t;
			t = x1;
			x1 = x2;
			x2 = t;
		}
		for(x = x1; x <= x2; x ++)
		{
			y = (x - x1) * (y2 - y1) / (x2 - x1) + y1;
			drawPixel(x, y, color);
		}
	}
}

void rectangle(u8_t x1,u8_t y1,u8_t x2,u8_t y2, u8_t color)
{
	line(x1,y1,x2,y1, color);
	line(x1,y1,x1,y2, color);
	line(x1,y2,x2,y2, color);
	line(x2,y1,x2,y2, color);
}
void filled_rectangle(u8_t x1,u8_t y1,u8_t x2,u8_t y2, u8_t color)
{
	u8_t i;
	for(i=y1;i<=y2;i++)
	{
		line(x1,i,x2,i, color);
	}
}

//在指定位置画一个指定大小的圆
//(x,y):中心点
//r    :半径
void circle(u8_t x0,u8_t y0,u8_t r, u8_t color)
{
	int a,b;
	int di;
	a = 0;
	b = r;
	di = 3 - 2 * r;             //判断下个点位置的标志
	while(a <= b)
	{
		drawPixel(x0-b, y0-a, color);             //3           
		drawPixel(x0+b, y0-a, color);             //0           
		drawPixel(x0-a, y0+b, color);             //1       
		drawPixel(x0-b, y0-a, color);             //7           
		drawPixel(x0-a, y0-b, color);             //2             
		drawPixel(x0+b, y0+a, color);             //4               
		drawPixel(x0+a, y0-b, color);             //5
		drawPixel(x0+a, y0+b, color);             //6 
		drawPixel(x0-b, y0+a, color);             
		a++;
		/***使用Bresenham算法画圆**/     
		if(di<0)
			di += 4*a + 6;	  
		else
		{
			di += 10 + 4*(a - b);   
			b--;
		}

		drawPixel(x0 + a, y0 + b, color);
	}
}






/*


void bin_plane_combine(u8_t* fbuf, plane_bbuf_t *plane)
{
	int m,n, fx, fy, px, py;
	int i,j;

	if(NULL == plane->bbuf)	//if not use,skip
		return;

	//计算横向交集	m为交集长度 fx为fb起始点 px为plane起始点
	m = 0; fx = 0; px = 0;
	if(plane->left < 0){	m = plane->left; px = -plane->left;}
	else fx = plane->left;
	if(plane->left + plane->width > SSD1306_LCDWIDTH) m = plane->left + plane->width - m;
	else m = SSD1306_LCDWIDTH - m;



	//计算纵向交集
	n = 0; fy = 0; py = 0;
	if(plane->top < 0){	n = plane->top; py = -plane->top;}
	else fy = plane->top;
	if(plane->top + plane->height > SSD1306_LCDHEIGHT) n = plane->top + plane->height - n;
	else n = SSD1306_LCDHEIGHT - n;


	if(plane->width + SSD1306_LCDWIDTH <= m)	return;	//横向无交集
	else	m = plane->width + SSD1306_LCDWIDTH - m;	//计算交集长度

	if(plane->height + SSD1306_LCDHEIGHT <= n)return;	//纵向无交集
	else n = plane->height + SSD1306_LCDHEIGHT - n;	//计算交集长度

	for(i = 0; i < n; i++)	//每一行
		for(j = 0; j < m; j++)
			if(plane->bbuf[px + j + ((py+i)/8)*SSD1306_LCDWIDTH] & _BV(((py+i)%8)))
				fbuf[fx + j + ((fy+i)/8)*SSD1306_LCDWIDTH] |= _BV(((fy+i)%8));	

}



typedef struct {
	int top;	//放置位置
	int left;
	u16_t width;
	u16_t height;

	u8_t *bbuf;
}plane_bbuf_t;	//二进制buf 一个字节代表8个点，从左上角起纵向摆放

#define FONT12X12_WIDTH 12
#define FONT12X12_HEIGHT 12
#define FONT6X12_WIDTH 6
#define FONT6X12_HEIGHT 12

#define BigLittleSwap16(A)  ((((u16_t)(A) & 0xff00) >> 8) | (((u16_t)(A) & 0x00ff) << 8))  

//常用ASCII表
//偏移量32
//ASCII字符集
//偏移量32
//大小:12*6
const u8_t asc2_1206[95][12]={
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//" ",0
{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},//"!",1
{0x00,0x00,0x30,0x00,0x40,0x00,0x30,0x00,0x40,0x00,0x00,0x00},//""",2
{0x09,0x00,0x0B,0xC0,0x3D,0x00,0x0B,0xC0,0x3D,0x00,0x09,0x00},//"#",3
{0x18,0xC0,0x24,0x40,0x7F,0xE0,0x22,0x40,0x31,0x80,0x00,0x00},//"$",4
{0x18,0x00,0x24,0xC0,0x1B,0x00,0x0D,0x80,0x32,0x40,0x01,0x80},//"%",5
{0x03,0x80,0x1C,0x40,0x27,0x40,0x1C,0x80,0x07,0x40,0x00,0x40},//"&",6
{0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"'",7
{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x20,0x40,0x40,0x20},//"(",8
{0x00,0x00,0x40,0x20,0x20,0x40,0x1F,0x80,0x00,0x00,0x00,0x00},//")",9
{0x09,0x00,0x06,0x00,0x1F,0x80,0x06,0x00,0x09,0x00,0x00,0x00},//"*",10
{0x04,0x00,0x04,0x00,0x3F,0x80,0x04,0x00,0x04,0x00,0x00,0x00},//"+",11
{0x00,0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//",",12
{0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x00},//"-",13
{0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//".",14
{0x00,0x20,0x01,0xC0,0x06,0x00,0x38,0x00,0x40,0x00,0x00,0x00},//"/",15
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},//"0",16
{0x00,0x00,0x10,0x40,0x3F,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},//"1",17
{0x18,0xC0,0x21,0x40,0x22,0x40,0x24,0x40,0x18,0x40,0x00,0x00},//"2",18
{0x10,0x80,0x20,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},//"3",19
{0x02,0x00,0x0D,0x00,0x11,0x00,0x3F,0xC0,0x01,0x40,0x00,0x00},//"4",20
{0x3C,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x23,0x80,0x00,0x00},//"5",21
{0x1F,0x80,0x24,0x40,0x24,0x40,0x34,0x40,0x03,0x80,0x00,0x00},//"6",22
{0x30,0x00,0x20,0x00,0x27,0xC0,0x38,0x00,0x20,0x00,0x00,0x00},//"7",23
{0x1B,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},//"8",24
{0x1C,0x00,0x22,0xC0,0x22,0x40,0x22,0x40,0x1F,0x80,0x00,0x00},//"9",25
{0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,0x00},//":",26
{0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x00,0x00,0x00,0x00,0x00},//";",27
{0x00,0x00,0x04,0x00,0x0A,0x00,0x11,0x00,0x20,0x80,0x40,0x40},//"<",28
{0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x00,0x00},//"=",29
{0x00,0x00,0x40,0x40,0x20,0x80,0x11,0x00,0x0A,0x00,0x04,0x00},//">",30
{0x18,0x00,0x20,0x00,0x23,0x40,0x24,0x00,0x18,0x00,0x00,0x00},//"?",31
{0x1F,0x80,0x20,0x40,0x27,0x40,0x29,0x40,0x1F,0x40,0x00,0x00},//"@",32
{0x00,0x40,0x07,0xC0,0x39,0x00,0x0F,0x00,0x01,0xC0,0x00,0x40},//"A",33
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},//"B",34
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x30,0x80,0x00,0x00},//"C",35
{0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},//"D",36
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x40,0x30,0xC0,0x00,0x00},//"E",37
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x00,0x30,0x00,0x00,0x00},//"F",38
{0x0F,0x00,0x10,0x80,0x20,0x40,0x22,0x40,0x33,0x80,0x02,0x00},//"G",39
{0x20,0x40,0x3F,0xC0,0x04,0x00,0x04,0x00,0x3F,0xC0,0x20,0x40},//"H",40
{0x20,0x40,0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x00,0x00},//"I",41
{0x00,0x60,0x20,0x20,0x20,0x20,0x3F,0xC0,0x20,0x00,0x20,0x00},//"J",42
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x0B,0x00,0x30,0xC0,0x20,0x40},//"K",43
{0x20,0x40,0x3F,0xC0,0x20,0x40,0x00,0x40,0x00,0x40,0x00,0xC0},//"L",44
{0x3F,0xC0,0x3C,0x00,0x03,0xC0,0x3C,0x00,0x3F,0xC0,0x00,0x00},//"M",45
{0x20,0x40,0x3F,0xC0,0x0C,0x40,0x23,0x00,0x3F,0xC0,0x20,0x00},//"N",46
{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},//"O",47
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x00,0x18,0x00,0x00,0x00},//"P",48
{0x1F,0x80,0x21,0x40,0x21,0x40,0x20,0xE0,0x1F,0xA0,0x00,0x00},//"Q",49
{0x20,0x40,0x3F,0xC0,0x24,0x40,0x26,0x00,0x19,0xC0,0x00,0x40},//"R",50
{0x18,0xC0,0x24,0x40,0x24,0x40,0x22,0x40,0x31,0x80,0x00,0x00},//"S",51
{0x30,0x00,0x20,0x40,0x3F,0xC0,0x20,0x40,0x30,0x00,0x00,0x00},//"T",52
{0x20,0x00,0x3F,0x80,0x00,0x40,0x00,0x40,0x3F,0x80,0x20,0x00},//"U",53
{0x20,0x00,0x3E,0x00,0x01,0xC0,0x07,0x00,0x38,0x00,0x20,0x00},//"V",54
{0x38,0x00,0x07,0xC0,0x3C,0x00,0x07,0xC0,0x38,0x00,0x00,0x00},//"W",55
{0x20,0x40,0x39,0xC0,0x06,0x00,0x39,0xC0,0x20,0x40,0x00,0x00},//"X",56
{0x20,0x00,0x38,0x40,0x07,0xC0,0x38,0x40,0x20,0x00,0x00,0x00},//"Y",57
{0x30,0x40,0x21,0xC0,0x26,0x40,0x38,0x40,0x20,0xC0,0x00,0x00},//"Z",58
{0x00,0x00,0x00,0x00,0x7F,0xE0,0x40,0x20,0x40,0x20,0x00,0x00},//"[",59
{0x00,0x00,0x70,0x00,0x0C,0x00,0x03,0x80,0x00,0x40,0x00,0x00},//"\",60
{0x00,0x00,0x40,0x20,0x40,0x20,0x7F,0xE0,0x00,0x00,0x00,0x00},//"]",61
{0x00,0x00,0x20,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00},//"^",62
{0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10},//"_",63
{0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//"`",64
{0x00,0x00,0x02,0x80,0x05,0x40,0x05,0x40,0x03,0xC0,0x00,0x40},//"a",65
{0x20,0x00,0x3F,0xC0,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},//"b",66
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x06,0x40,0x00,0x00},//"c",67
{0x00,0x00,0x03,0x80,0x04,0x40,0x24,0x40,0x3F,0xC0,0x00,0x40},//"d",68
{0x00,0x00,0x03,0x80,0x05,0x40,0x05,0x40,0x03,0x40,0x00,0x00},//"e",69
{0x00,0x00,0x04,0x40,0x1F,0xC0,0x24,0x40,0x24,0x40,0x20,0x00},//"f",70
{0x00,0x00,0x02,0xE0,0x05,0x50,0x05,0x50,0x06,0x50,0x04,0x20},//"g",71
{0x20,0x40,0x3F,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},//"h",72
{0x00,0x00,0x04,0x40,0x27,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},//"i",73
{0x00,0x10,0x00,0x10,0x04,0x10,0x27,0xE0,0x00,0x00,0x00,0x00},//"j",74
{0x20,0x40,0x3F,0xC0,0x01,0x40,0x07,0x00,0x04,0xC0,0x04,0x40},//"k",75
{0x20,0x40,0x20,0x40,0x3F,0xC0,0x00,0x40,0x00,0x40,0x00,0x00},//"l",76
{0x07,0xC0,0x04,0x00,0x07,0xC0,0x04,0x00,0x03,0xC0,0x00,0x00},//"m",77
{0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},//"n",78
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},//"o",79
{0x04,0x10,0x07,0xF0,0x04,0x50,0x04,0x40,0x03,0x80,0x00,0x00},//"p",80
{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x50,0x07,0xF0,0x00,0x10},//"q",81
{0x04,0x40,0x07,0xC0,0x02,0x40,0x04,0x00,0x04,0x00,0x00,0x00},//"r",82
{0x00,0x00,0x06,0x40,0x05,0x40,0x05,0x40,0x04,0xC0,0x00,0x00},//"s",83
{0x00,0x00,0x04,0x00,0x1F,0x80,0x04,0x40,0x00,0x40,0x00,0x00},//"t",84
{0x04,0x00,0x07,0x80,0x00,0x40,0x04,0x40,0x07,0xC0,0x00,0x40},//"u",85
{0x04,0x00,0x07,0x00,0x04,0xC0,0x01,0x80,0x06,0x00,0x04,0x00},//"v",86
{0x06,0x00,0x01,0xC0,0x07,0x00,0x01,0xC0,0x06,0x00,0x00,0x00},//"w",87
{0x04,0x40,0x06,0xC0,0x01,0x00,0x06,0xC0,0x04,0x40,0x00,0x00},//"x",88
{0x04,0x10,0x07,0x10,0x04,0xE0,0x01,0x80,0x06,0x00,0x04,0x00},//"y",89
{0x00,0x00,0x04,0x40,0x05,0xC0,0x06,0x40,0x04,0x40,0x00,0x00},//"z",90
{0x00,0x00,0x00,0x00,0x04,0x00,0x7B,0xE0,0x40,0x20,0x00,0x00},//"{",91
{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xF0,0x00,0x00,0x00,0x00},//"|",92
{0x00,0x00,0x40,0x20,0x7B,0xE0,0x04,0x00,0x00,0x00,0x00,0x00},//"}",93
{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},//"~",94
}; 



void put_font6x12(int c, int x, int y, u8_t color, u8_t bkcolor, plane_bbuf_t *pln)
{
	u8_t i, j;
	u16_t *font = (u16_t*)asc2_1206[c - ' '];

	for (i=0; i < FONT6X12_WIDTH ; i++){
		u16_t bit_bigend = BigLittleSwap16(font[i]);
		for (j = 0; j < FONT6X12_HEIGHT; j++)
		{
			if ( (bit_bigend << j) & 0x8000)
				bin_plane_drawPixel(x+i, y+j, color, pln); // 字符颜色
			else
				bin_plane_drawPixel(x+i, y+j, bkcolor, pln); // 背景颜色
		}
	}
}


void bin_plane_drawPixel(int x, int y, u8_t color, plane_bbuf_t *pln)
{
	if(x >= pln->width)return;
	if(y >= pln->height)return;
	if(x < 0)return;
	if(y < 0)return;

	if (color) 
		pln->bbuf[x+ (y/8)*pln->width] |= _BV((y%8));	
	else
		pln->bbuf[x+ (y/8)*pln->width] &= ~_BV((y%8)); 

}



void put_font12x12(u16_t bits[12], int x, int y, u8_t color, u8_t bkcolor, plane_bbuf_t *pln)
{
	u8_t i, j;
	for (i=0; i < FONT12X12_WIDTH; i++){
		u16_t bit_bigend = BigLittleSwap16(bits[i]);
		for (j = 0; j < FONT12X12_HEIGHT; j++)
		{
			if ( (bit_bigend << j) & 0x8000)
				bin_plane_drawPixel(x+i, y+j, color, pln); // 字符颜色
			else
				bin_plane_drawPixel(x+i, y+j, bkcolor, pln); // 背景颜色
		}
	}
}






//12*12大小的汉字每个汉字点阵需要24个字节，可以得到整个GBK码12字库的大小为：24*23940
//将gbk串对应点阵 写到plane的相应位置上，返回已经输出gbk字节数量
//如果遇到非gbk编码 会跳出

int gbkString2Font12x12Bitmap(u8_t gbk[], size_t gbk_len, int x, int y, u8_t color, u8_t bkcolor, plane_buf_t *pln)
{
	int ret = STATE_OK;
	FIL fobj;
	if(FR_OK != (ret = api_fs.f_open(&fobj, "/app/oledi2c/GBK12.FON", FA_OPEN_EXISTING | FA_READ))){
		LOG_INFO("Font12 file open err:%d.\r\n", ret);
		return 0;
	}


	u8_t *pgbk = gbk;
	int offset;

	while(pgbk - gbk < gbk_len && 
		(offset = gbkfont12offset(pgbk[1], pgbk[0])) >= 0){
		u16_t bits[12];
		UINT n;

		//读取相应位置上的24字节
		if(offset < 0 ||
		    FR_OK != (ret = api_fs.f_lseek(&fobj, offset)) ||
		    FR_OK != (ret = api_fs.f_read(&fobj, bits, sizeof(bits), &n)) ||
		    sizeof(bits) != n){
			LOG_INFO("Font12 read err:%d.\r\n", ret);
			break;
		}
		put_font12x12(bits, x, y, color, bkcolor, pln);
		x += FONT12X12_WIDTH;

		pgbk += 2;
	}



	api_fs.f_close(&fobj);

	return pgbk - gbk;

}


//============== 中文编码的主题 ==============

//在线查询编码
//http://bianma.911cha.com/

//关于unicode中文编码范围 请参考下面的链接：
//http://blog.oasisfeng.com/2006/10/19/full-cjk-unicode-range/

//关于unicode 和utf8 请看：
//http://wenku.baidu.com/view/e0ea42fa700abb68a982fbea

//==============


//输入 utf8 字节数组
//输出 unicode 数组，字母输出双字节
//返回已经转换的unicode的数量
// out_ucs_max 是双字节单元的数目限制 不是buf尺寸

int utf8_to_unicode_buf(const u8_t* putf_in, size_t insize, size_t*inlen, u16_t* pucs_out, size_t out_ucs_max)
{
	const u8_t *putf;
	u16_t  *pucs;

	putf = putf_in;
	pucs = pucs_out;

	while (*putf && putf < putf_in + insize && pucs < pucs_out+out_ucs_max )
	{
		if (*putf > 0x00 && *putf <= 0x7F) // 处理单字节UTF8字符
		{
			*pucs++	= *putf++; 	   // 小端法表示, 在高地址填补0

		}
		else if (((*putf) & 0xE0) == 0xC0) // 处理双字节UTF8字符
		{
			u8_t utf_high, utf_low, uc_high, uc_low;
			utf_high = *putf; 
			utf_low = *(putf + 1);
			if ((utf_low & 0xC0) != 0x80) // 检查是否为合法的UTF8字符表示
				break;

			uc_low = (utf_high << 6) + (utf_low & 0x3F);
			uc_high = (utf_high >> 2) & 0x07;
			*pucs++ = SHORTVAL_LE(uc_low, uc_high);
			putf += 2;
		}
		else if (((*putf) & 0xF0) == 0xE0) // 处理三字节UTF8字符
		{
			u8_t utf_high, utf_mid, utf_low, uc_high, uc_low;

			utf_high   = *putf;
			utf_mid = *(putf + 1);
			utf_low	= *(putf + 2);
			if (((utf_mid & 0xC0) != 0x80) || ((utf_low & 0xC0) != 0x80))
				break;

			uc_low = (utf_mid << 6) + (utf_low & 0x3F);
			uc_high = (utf_high << 4) + ((utf_mid >> 2) & 0x0F);
			
			*pucs++ = SHORTVAL_LE(uc_low, uc_high);
			putf += 3;
		}
		else //对于其他字节数的UTF8字符不进行处理
			break;

	}

	if(pucs < pucs_out+out_ucs_max)	//若尾部有空间 可以加0
		*pucs = 0;

	if(inlen)
		*inlen = putf - putf_in;	//如果需要 可以将已经读入的数量返回

	return pucs - pucs_out;

}



//	UNICODE码表的制作方法是将UNICODE码从低到高顺序排列，然后在对应的位置存放GBK码的码值就可以了，
//	这样我们就可以通过UNICODE码快速的找到GBK码。
//	UNICODE码中用于存放汉字的字段为0X4E00~0X9FA5，总共20902个汉字。
//	我们将这些对应的汉字的GBK码顺序存入相应的位置，就得到了UNICODE到GBK的转换码表。
//	加入的标点符号总共97 个，对应UNICODE码的 0XFF01~0XFF61。

//	每个GBK码占用了2个字节，所以整个UNICODE转GBK码码表文件的大小为：2*（20902+97）=41998个字节（42K）。

//将UNICODE码转换为GBK码
//unicode:UNICODE码
//返回值:GBK码
u16_t ucs2gbk_from_tabfile(u16_t unicode, FIL*fp)
{
   	u32_t offset;
	u8_t temp[2];
	UINT n;

	if(unicode <= 0X9FA5)
		offset = unicode-0X4E00;
	else if(unicode > 0X9FA5){	//是标点符号

		if(unicode < 0XFF01 ||unicode > 0XFF61)
			return 0;	//没有对应编码
		else
			offset = unicode-0XFF01+0X9FA6-0X4E00;    
	}

	if(FR_OK != api_fs.f_lseek(fp, offset*2) ||
	    FR_OK != api_fs.f_read(fp, temp, sizeof(temp), &n) ||
	    sizeof(temp) != n)
	    return 0;	//故障

	//SPI_Flash_Read(temp,offset*2+UNI2GBKADDR,2);//得到GBK码   
	return SHORTVAL_LE(temp[0], temp[1]); //返回找到的编码
}




//输入双字节unicode数组
//输出字节gbk数组
//ucs_char_num 是unicode数量 非buf空间长度
//ucs_char_len 可以用来输出已经读取的unicode数
//返回输出字节数
int UnicodeToGBK(u16_t *ucs, size_t ucs_char_num, size_t *ucs_char_len, u8_t* gbk, size_t size_gbk)
{   					  
	int ret = STATE_OK;
	FIL fobj;
	u16_t *pucs = ucs;
	u8_t *pgbk = gbk;
	if(FR_OK != (ret = api_fs.f_open(&fobj, "/app/oledi2c/UCS2GBK", FA_OPEN_EXISTING | FA_READ))){
		LOG_INFO("UCS2GBK file open err:%d.\r\n", ret);
		return 0;
	}



	while(0 != *pucs && 0xFFFF != *pucs && 
		pucs - ucs < ucs_char_num && 
		pgbk - gbk < size_gbk){

		if((*pucs&0xff00) == 0){	//字母

			if(*pucs >= 0x20 && *pucs <= 0x7e)
				*pgbk++ = (u8_t)*pucs;
			else
				*pgbk++ = '.';	//无法识别的用？代替 

		}
		else if(*pucs >= 0X4E00){//是汉字
			u16_t tmp = ucs2gbk_from_tabfile(*pucs, &fobj);//把unicode转换为gb2312 	   
			pgbk[0] = tmp>>8;	 
			pgbk[1] =(u8_t)tmp;
			pgbk+=2;
		}
		else 
			*pgbk++ = '.';	//无法识别的用？代替  

		pucs++;
	}    

	if(ucs_char_len)
		*ucs_char_len = pucs - ucs;

	if(pgbk - gbk < size_gbk)	//如果空间足够 尾部加0
		*pgbk = '\0';


	api_fs.f_close(&fobj);

	return pgbk - gbk;
}

//指定ascii数组及长度，字符非法 则退出
//返回已经输出的ascii字符数目
int asciiString2Font6x12Bitmap(u8_t asc[], size_t asc_len, int x, int y, u8_t color, u8_t bkcolor, plane_bbuf_t *pln)
{
	u8_t *pasc = asc;
	while(*pasc != 0 && *pasc < 128 && pasc - asc < asc_len){
		put_font6x12(*pasc, x, y, color, bkcolor, pln);
		x += FONT6X12_WIDTH;

		pasc++;
	}
	return pasc - asc;
}

#define PLANE_NUM_MAX 3

plane_bbuf_t plane[PLANE_NUM_MAX];


char msg[128] = "Hello from wifi.io";
#define msg_new msg
char msg_flag = 0;


#define PLANE_SCROLL_MESSAGE 2
#define PLANE_SCROLL_MESSAGEB 0
int scroll_thread(void* p)
{
	_tick_sleep(1000);
	LOG_INFO("scroll_thread start.\r\n");

	//文字更新
	while(1){

//		plane_init(PLANE_SCROLL_MESSAGE, _strlen(msg) * 6, 7, 0, NCOL_NUM);	//init plane
//		put_string5x7(0, 0, msg, COLOR_BLUE, 0, &plane[PLANE_SCROLL_MESSAGE]);

		{
			int n;
			size_t size;
			u8_t cbuf[256];
			int plane_width, plane_height;

			//首先转成unicode
			n = utf8_to_unicode_buf((u8_t*)msg, sizeof(msg), &size, (u16_t*)cbuf, sizeof(cbuf)/2);	// utf8 -> unicode
//			api_console.hexdump((char*)cbuf, n*2, 0);

			//其次转成gbk(含单字节ascii)
			n = UnicodeToGBK((u16_t*)cbuf, n, &size, cbuf, sizeof(cbuf));	//双字节转换为双字节或者单字节，相同buf不会导致问题
//			api_console.hexdump((char*)cbuf, n, 0);

			//根据gbk编码 确定总体宽度，init plane
			{	//计算plane的尺寸
				int i;
				plane_width = 0;
				plane_height = FONT6X12_HEIGHT;
				for(i = 0; i < n; ){
					if(cbuf[i] < 128){
						plane_width += FONT6X12_WIDTH;
						i += 1;
					}
					else{
						plane_width += FONT12X12_WIDTH;
						plane_height = FONT12X12_HEIGHT;
						i += 2;
					}

//					else{
//						plane_width += FONT16X16_WIDTH;
//						plane_height = FONT16X16_HEIGHT;
//						i += 2;
//					}

				}
				LOG_INFO("----- plane: %d %d.\r\n", plane_width, plane_height);
				plane_init(PLANE_SCROLL_MESSAGE, plane_width, plane_height, 0, NCOL_NUM);	//init plane
			}

			//根据gbk编码 放置bitmap
			{
				int x, i, j;
				i = 0;
				x = 0;
				while(i < n){

					if((j = asciiString2Font6x12Bitmap(cbuf+i, n-i, x, plane_height - FONT6X12_HEIGHT, 1, 0, &plane[PLANE_SCROLL_MESSAGE])) > 0){
						i += j;
						x += FONT6X12_WIDTH * j;
						LOG_INFO("----- 7x5 %d.x: %d\r\n", j, x);
					}
					else if((j = gbkString2Font12x12Bitmap(cbuf+i, n-i, x, 0, 1, 0, &plane[PLANE_SCROLL_MESSAGE])) > 0){
						i += j;
						x += FONT12X12_WIDTH * j/2;
						LOG_INFO("----- 12x12 %d.x: %d\r\n", j, x);
					}

					
					else{
						LOG_WARN("Char error @ %d.\r\n", i);
						break;
					}
				}
			}


		}
		

//		u16_t gbk[] = {0xD6A7, 0xB3D6, 0xD6D0, 0xCEC4, 0xC0B2};
//		ret = gbkString2Font16x16Bitmap(gbk, 5, 0, 0, COLOR_BLUE, 0, &plane[PLANE_SCROLL_MESSAGE]);
//		LOG_INFO("bitmap ret:%d.\r\n", ret);


		//当没有新的消息时 循环滚动文字
		while(0 == msg_flag){

			plane[PLANE_SCROLL_MESSAGE].left -= 1;
			if(plane[PLANE_SCROLL_MESSAGE].left + plane[PLANE_SCROLL_MESSAGE].width < 0)
				plane[PLANE_SCROLL_MESSAGE].left = NCOL_NUM;


			_tick_sleep(30);
		}

		_strcpy(msg, msg_new);	//更新msg	并清空flag
		msg_flag = 0;
	}

	return 0;
}



*/





void begin(u8_t vccstate)
{
	ssd1306_command(SSD1306_DISPLAYOFF);	// 0xAE
	ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);	// 0xD5
	ssd1306_command(0x80);	// the suggested ratio 0x80
	ssd1306_command(SSD1306_SETMULTIPLEX);	// 0xA8
	ssd1306_command(0x3F);
	ssd1306_command(SSD1306_SETDISPLAYOFFSET);	// 0xD3
	ssd1306_command(0x0);	 // no offset
	ssd1306_command(SSD1306_SETSTARTLINE | 0x0);	// line #0
	ssd1306_command(SSD1306_CHARGEPUMP);	// 0x8D
	if (vccstate == SSD1306_EXTERNALVCC) 
	{ ssd1306_command(0x10); }
	else 
	{ ssd1306_command(0x14); }
	ssd1306_command(SSD1306_MEMORYMODE);	// 0x20
	ssd1306_command(0x00);	// 0x0 act like ks0108
	ssd1306_command(SSD1306_SEGREMAP | 0x1);
	ssd1306_command(SSD1306_COMSCANDEC);
	ssd1306_command(SSD1306_SETCOMPINS);	// 0xDA
	ssd1306_command(0x12);
	ssd1306_command(SSD1306_SETCONTRAST);	 // 0x81
	if (vccstate == SSD1306_EXTERNALVCC) 
	{ ssd1306_command(0x9F); }
	else 
	{ ssd1306_command(0xCF); }
	ssd1306_command(SSD1306_SETPRECHARGE);	// 0xd9
	if (vccstate == SSD1306_EXTERNALVCC) 
	{ ssd1306_command(0x22); }
	else 
	{ ssd1306_command(0xF1); }
	ssd1306_command(SSD1306_SETVCOMDETECT);	 // 0xDB
	ssd1306_command(0x40);
	ssd1306_command(SSD1306_DISPLAYALLON_RESUME);	 // 0xA4
	ssd1306_command(SSD1306_NORMALDISPLAY);	 // 0xA6

	ssd1306_command(SSD1306_DISPLAYON);//--turn on oled panel
}



////////////////////////////////////////
//每一个addon都有main，该函数在加载后被运行
// 这里适合:
// addon自身运行环境检查；
// 初始化相关数据；

//若返回 非 ADDON_LOADER_GRANTED 将导致函数返回后
//被卸载

//该函数的运行上下文 是wifiIO进程
////////////////////////////////////////

int main(int argc, char* argv[])
{
	u8_t u, v;
	LOG_INFO("main: oledi2c attached...\r\n");

	i2c_sim.init(&(ssd1306_dev.i2c_dev), OLED_I2C_SDA, OLED_I2C_SCL, 5);

	begin(SSD1306_SWITCHCAPVCC);

//	clearDisplay();
	_tick_sleep(3000);

	rectangle(5, 10, 100, 50, 1);

	circle(50,30,20,1);

	_tick_sleep(3000);

	for(u = 0, v = 10; ; u+=5, v+=5){
		clearDisplay();
		circle(u%128,v%64,20,1);

		display();
//		_tick_sleep(2);
	}


	return ADDON_LOADER_GRANTED;
//err_exit:
//	return ADDON_LOADER_ABORT;
}







